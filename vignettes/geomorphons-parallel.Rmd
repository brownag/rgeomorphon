---
title: "Parallel Processing with 'rgeomorphon'"
knit: litedown:::knit
vignette: >
  %\VignetteIndexEntry{Parallel Processing with 'rgeomorphon'}
  %\VignetteEngine{litedown::vignette}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
# Sys.setenv(R_RGEOMORPHON_RUN_LONG_EXAMPLES = TRUE)
litedown::reactor(
    eval = (
        isTRUE(as.logical(
            Sys.getenv("R_RGEOMORPHON_RUN_LONG_EXAMPLES", unset = "FALSE")
        )) &&
            requireNamespace("terra", quietly = TRUE) &&
            all(c("future", "future.apply", "parallel") %in%
                    rownames(installed.packages()))
    )
)
```

```{r setup}
library(rgeomorphon)
```

When working with large Digital Elevation Models (DEMs), calculating geomorphons can be time-consuming. `rgeomorphon` can speed up this process by using parallel processing. This vignette explains how to set up and use the parallel processing features of the package.

## The Core Concept: Tiled Processing

Parallel processing in `rgeomorphon` is achieved by splitting the input raster into smaller tiles. Each tile is then processed independently on a separate worker. The results are then combined back into a single, seamless raster.

This tiled approach is typically used automatically when a raster is too large to fit in memory. However, you can influence this behavior to leverage tiled processing on smaller datasets.

## The `future` Ecosystem

### The Two Layers of Parallelism in `rgeomorphon`

`rgeomorphon` offers two distinct layers of parallelism to accelerate calculations. This parallelism allows `rgeomorphon` to perform optimally across a vast range of hardware, from a personal laptop to a high-performance computing (HPC) cluster.

1.  **Low-Level Parallelism (within a single chunk):** At its core, `rgeomorphon` uses **`RcppParallel`** to execute the main geomorphon algorithm in C++. This provides efficient, multi-threaded computation on a single data chunk. When you run `geomorphons()` on a raster that fits in memory, `RcppParallel` will automatically attempt to use multiple CPU cores to speed up the calculation. This is a form of shared-memory parallelism that works "out of the box."

2.  **High-Level Parallelism (across multiple chunks):** For rasters that are too large to fit in memory, `rgeomorphon` divides the data into smaller, independent tiles. This is where the **`future`** package ecosystem comes in. You can control how these independent tiles are processed by providing a parallel `lapply`-like function to the `LAPPLY.FUN` argument. This allows you to distribute the processing of *entire tiles* across multiple R sessions, either on a single machine (`multisession`) or even across a computer cluster (`cluster`).

In short, `RcppParallel` speeds up the work *inside* each tile, while `future` can be used to process *multiple tiles* at the same time. 

To use the high-level, tiled parallelism, you must do two things:
1.  **Set a `future` plan:** This tells R *how* to distribute the tiles. For example, `plan(multisession)` tells `future` to use separate R sessions on your local machine.
2.  **Provide a parallel `lapply` function:** You need to pass a parallel-aware loop function to `geomorphons()` via the `LAPPLY.FUN` argument. The `future.apply` package provides the `future_lapply()` function for this purpose.

### Scaling Up: From a Laptop to a Cluster

A key design principle in `rgeomorphon` is that the code for your geomorphon calculation should not have to change as your computing environment becomes more powerful. The package achieves this by separating the *what* from the *how* of parallel processing. The `geomorphons()` function defines *what* to compute, while the **`future`** framework lets you decide *how* and *where* to compute it.

The only piece of code you need to change to switch between different parallel strategies is the `future::plan()`. This single command configures the entire backend. Let's look at a few common scenarios.

#### Scenario 1: Sequential Processing (No Parallelism)

To disable all high-level parallelism and process tiles one-by-one in your main R session, you use `plan(sequential)`. This is great for debugging or for situations where the overhead of parallelism isn't worth it.

```r
library(future)

# Process everything in the current R session, one tile after another.
plan(sequential)
```

#### Scenario 2: Local Multicore Processing

This is the most common scenario for users with a modern multi-core laptop or workstation. `plan(multisession)` starts several new, independent R sessions in the background on your local machine. Each session will work on a different tile of the raster.

```r
# Use 4 background R sessions on this computer
plan(multisession, workers = 4)
```
On this backend, the low-level `RcppParallel` engine within each worker will still try to use multiple threads, so they will be competing for the same CPU cores. Even so, this is a simple and effective way to parallelize on a single machine.

#### Scenario 3: Distributed Cluster Processing

This is where the two-level parallel design truly shines. If you have access to a High-Performance Computing (HPC) cluster or several machines on a network, you can use the `cluster` backend. The `future` framework will handle the logistics of sending individual tiles to different machines for processing.

```r
# Distribute work to two specific machines on the local network
plan(cluster, workers = c("machine1.local", "machine2.local"))
```

In this setup, `rgeomorphon` will send a tile to `machine1.local`. Once it arrives, the `RcppParallel` engine on `machine1.local` will take over and use all of its local cores to process that tile as fast as possible. This allows you to scale your processing power far beyond the limits of a single computer.

### The `geomorphons()` Call Stays the Same

Regardless of which of the powerful backends you configure with `future::plan()`, your call to `geomorphons()` remains identical. You write your code once, and can scale it up simply by changing the plan.

```r
g_forms <- geomorphons(
    my_large_dem,
    search = 50,
    LAPPLY.FUN = function(X, FUN, ...) {
        future.apply::future_lapply(X, FUN, future.seed = TRUE, ...)
    }
)

# Remember to always return to a sequential plan to shut down workers
plan(sequential)
```

To learn more about the different `future` backends and their configuration options (including for job schedulers like Slurm or TORQUE), we highly recommend exploring the documentation and vignettes on the official **[`future` package website](https://future.futureverse.org/)**.

## A Demonstration with `salton`

Let's demonstrate this with the `salton` dataset included with `rgeomorphon`. This dataset is small and would not normally trigger tiled processing.

```{r}
library(rgeomorphon)
library(terra)
library(future)
library(future.apply)

# Load the salton dataset and prepare it as a SpatRaster
data("salton", package = "rgeomorphon")
dem <- terra::rast(salton)
names(dem) <- "Elevation"
crs(dem) <- attr(salton, "crs")
ext(dem) <- attr(salton, "extent")

# By default, this small raster is processed in a single chunk
geomorphon_chunks_needed(dem)
```

To force tiled processing we can manipulate the environment variables that `rgeomorphon` uses to estimate memory needs. We will set `R_RGEOMORPHON_N_WORKERS` to tell the function how many parallel jobs we intend to run.

```{r}
# Scale up the memory needed (equivalent number of tile copies)
Sys.setenv(R_RGEOMORPHON_MEM_SCALE_NEED = 1e5)

# which will cause the chunking algorithm to divide the raster
geomorphon_chunks_needed(dem)
```

Now that `geomorphons()` will use a tiled approach, we can set up our parallel plan and execute the calculation.

```{r}
# Set up a multisession future plan with 4 workers
# This creates 4 background R sessions to do the work
future::plan(multisession, workers = 4)
```
Use the LAPPLY.FUN argument to pass future.apply::future_lapply. This tells geomorphons() to use the future backend for processing tiles

```{r}
system.time({
    g_parallel <- geomorphons(
        dem,
        search = 10,
        flat = 0.1,
        LAPPLY.FUN = function(X, FUN, ...) {
            future.apply::future_lapply(X, FUN, future.seed = TRUE, ...)
        }
    )
})

# Shut down the parallel workers
future::plan(sequential)

# Unset the environment variable
Sys.unsetenv("R_RGEOMORPHON_MEM_SCALE_NEED")
```

```{r}
# Inspect
terra::plot(g_parallel, main = "Geomorphons via Parallel Processing")
```

### Important Notes

*   **Overhead:** For small datasets like `salton`, the overhead of setting up parallel sessions and tiling the data will make the process *slower* than a simple sequential calculation. The benefits of parallel processing become apparent with larger rasters.
*   **`future.seed = TRUE`:** Using `future.seed = TRUE` is highly recommended to ensure that any random number generation is handled properly across the parallel sessions, making your results reproducible.
*   **Backend Flexibility:** The `future` package allows for many different parallel backends. The `geomorphons()` code remains exactly the same.

## Beyond Parallelism: The Flexibility of `LAPPLY.FUN`

While `future.apply::future_lapply` is the recommended way to achieve scalable, high-level parallelism, the `LAPPLY.FUN` argument is intentionally designed as a generic interface. It is not locked into the `future` ecosystem. You can provide **any R function** that behaves like `base::lapply()`, giving you an advanced level of control over how tiles are processed.

This allows for many customizations, for example:

1.  **Using Alternative Parallel Backends:** If you prefer a different parallel framework, such as the one provided by the base `parallel` package, you can easily integrate it.

    ```{r}
    # Example using the base R parallel package
    library(parallel)
    cl <- makeCluster(4)

    g_forms_par <- geomorphons(
        dem,
        search = 10,
        flat = 0.1,
        LAPPLY.FUN = function(X, FUN, ...) {
            parLapply(cl, X, FUN, ...)
        }
    )

    stopCluster(cl)
    ```

2.  **Injecting Progress Reporting and Logging:** For very large datasets, processing can take a long time. You can use `LAPPLY.FUN` to create a wrapper function that provides real-time feedback or writes to a log file as each tile is completed. This doesn't require any parallel backend; it simply modifies the loop's behavior.

    In the example below, we create a custom function that prints a message before and after processing each tile.

    ```{r}
    # Define a custom lapply-like function that adds reporting
    reporting_lapply <- function(X, FUN, ...) {
        # This is our wrapper. It takes the tile index 'i' as input.
        reporting_FUN <- function(i) {
            message(paste0("--> Starting tile #", i, " at ", Sys.time()))
            result <- FUN(i, ...)
            message(paste0("<-- Finished tile #", i, " at ", Sys.time()))
            return(result)
        }

        message("Finished creating tiles, processing ...")
        # Use a sequential lapply to execute our reporting wrapper
        base::lapply(X, reporting_FUN)
    }

    # Pass our custom function to geomorphons()
    g_forms_reported <- geomorphons(
        dem,
        search = 10,
        flat = 0.1,
        LAPPLY.FUN = reporting_lapply
    )
    ```
    
    This would print a start and end message to the console for every tile processed, giving you a live view of the progress.

This hook makes the tile-processing loop fully customizable, allowing for logging, error handling, or integration with virtually any sequential or parallel looping mechanism in the R ecosystem.
